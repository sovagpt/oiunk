<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OINK FM 24.7 - AI Crypto Radio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .radio-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: fit-content;
            margin: 0 auto;
        }

        .logo {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tagline {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .visual-container {
            position: relative;
            width: 1403px;
            height: 992px;
            margin: 20px auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            background: #000;
        }

        .studio-img, .porky-gif {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .porky-gif {
            display: none;
        }

        .studio-img.visible {
            display: block;
        }

        .porky-gif.visible {
            display: block;
        }

        /* Perky Reporter Styles */
        .perky-reporter {
            position: absolute;
            left: -400px; /* Start off-screen */
            top: 50%;
            transform: translateY(-50%);
            width: 350px;
            height: 600px;
            z-index: 10;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            opacity: 0;
        }

        .perky-reporter.visible {
            left: 20px; /* Slide into frame */
            opacity: 1;
        }

        .perky-reporter img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        /* Perky Reporter Badge */
        .perky-badge {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.3);
            border: 2px solid white;
        }

        .status-display {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff41;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff41;
            border: 2px solid #00ff41;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.stop {
            background: linear-gradient(45deg, #ff4757, #ff3742);
        }

        .btn.breaking {
            background: linear-gradient(45deg, #ff9500, #ff6b00);
            animation: pulse-orange 2s infinite;
        }

        .btn.knowledge {
            background: linear-gradient(45deg, #9c88ff, #6c63ff);
        }

        .btn.perky {
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            animation: pulse-pink 2s infinite;
        }

        @keyframes pulse-orange {
            0% { box-shadow: 0 0 0 0 rgba(255, 149, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 149, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 149, 0, 0); }
        }

        @keyframes pulse-pink {
            0% { box-shadow: 0 0 0 0 rgba(255, 20, 147, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 20, 147, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 20, 147, 0); }
        }

        .audio-player {
            width: 100%;
            margin: 20px 0;
            border-radius: 10px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .config-section h3 {
            color: #fff;
            margin-bottom: 15px;
        }

        .config-section input, .config-section textarea, .config-section select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.9);
        }

        .topic-section {
            background: rgba(108, 99, 255, 0.1);
            border: 2px solid #6c63ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .topic-section h3 {
            color: #6c63ff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topic-input {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #6c63ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-size: 14px;
            min-height: 100px;
            resize: vertical;
        }

        .topic-input:focus {
            outline: none;
            border-color: #9c88ff;
            box-shadow: 0 0 10px rgba(108, 99, 255, 0.3);
        }

        .topic-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .topic-queue {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .topic-item {
            background: rgba(108, 99, 255, 0.2);
            border-left: 4px solid #6c63ff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            color: #fff;
            position: relative;
        }

        .topic-item.urgent {
            border-left-color: #ff6b00;
            background: rgba(255, 149, 0, 0.2);
        }

        .topic-item.perky-report {
            border-left-color: #ff1493;
            background: rgba(255, 20, 147, 0.2);
        }

        .topic-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            opacity: 0.8;
        }

        .topic-content {
            font-size: 14px;
            margin: 5px 0;
        }

        .topic-tags {
            font-size: 11px;
            color: #6c63ff;
            margin-top: 5px;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .remove-btn:hover {
            background: #ff3742;
        }

        .news-ticker {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff41;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 100px;
            overflow-y: auto;
        }

        .stats-display {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            color: #fff;
            min-width: 100px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .knowledge-section {
            background: rgba(156, 136, 255, 0.1);
            border: 2px solid #9c88ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .knowledge-section h3 {
            color: #9c88ff;
            margin-bottom: 15px;
        }

        .knowledge-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .knowledge-item {
            color: #fff;
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid #9c88ff;
            background: rgba(156, 136, 255, 0.1);
            border-radius: 3px;
            font-size: 13px;
        }

        /* Reporter Type Toggle */
        .reporter-toggle {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }

        .toggle-label {
            color: #fff;
            font-size: 14px;
            margin-right: 10px;
        }

        .reporter-options {
            display: flex;
            gap: 10px;
        }

        .reporter-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #6c63ff;
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .reporter-option.perky {
            border-color: #ff1493;
        }

        .reporter-option.active {
            background: #6c63ff;
        }

        .reporter-option.perky.active {
            background: #ff1493;
        }
    </style>
</head>
<body>
    <div class="radio-container">
        <div class="logo">OINK FM</div>
        <div class="tagline">24.7 AI Crypto & Memecoin Radio - Hosted by Porky</div>
        
        <div class="visual-container">
            <!-- Studio Image -->
            <img id="studioImg" class="studio-img visible" 
                 src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/studio.jpg" 
                 alt="Studio">
            
            <!-- Porky GIF -->
            <img id="porkyGif" class="porky-gif" 
                 src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/porky.gif" 
                 alt="Porky">

            <!-- Perky Reporter -->
            <div id="perkyReporter" class="perky-reporter">
                <img src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/reporter.gif" alt="Perky Reporter">
                <div class="perky-badge">üì∫ PERKY LIVE</div>
            </div>
        </div>

        <div class="status-display" id="statusDisplay">
            üéôÔ∏è Ready to broadcast... Click Start Show!
        </div>

        <div class="stats-display">
            <div class="stat-box">
                <div class="stat-number" id="queueCount">0</div>
                <div class="stat-label">Topics Queued</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="memoryCount">0</div>
                <div class="stat-label">Memory Entries</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="knowledgeCount">0</div>
                <div class="stat-label">Knowledge Items</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="songCount">0</div>
                <div class="stat-label">Songs Available</div>
            </div>
        </div>

        <div class="news-ticker" id="newsTicker">
            Latest crypto intel will appear here...
        </div>

        <div class="controls">
            <button class="btn" onclick="startShow()">üéôÔ∏è Start Show</button>
            <button class="btn stop" onclick="stopShow()">‚èπÔ∏è Stop Show</button>
            <button class="btn" onclick="skipToNext()">‚è≠Ô∏è Skip Segment</button>
            <button class="btn breaking" onclick="breakingNews()">üì° Breaking News</button>
            <button class="btn perky" onclick="perkyReport()">üì∫ Perky Report</button>
            <button class="btn knowledge" onclick="viewKnowledge()">üß† View Knowledge</button>
        </div>

        <audio class="audio-player" id="audioPlayer" controls>
            Your browser does not support the audio element.
        </audio>

        <div class="topic-section">
            <h3>üéØ Topic Queue Management</h3>
            <p style="color: #fff; margin-bottom: 10px;">
                <strong>Curate what Porky discusses!</strong> Add topics and he'll work through them with his growing knowledge.
            </p>
            
            <textarea id="topicInput" class="topic-input" 
                      placeholder="What should Porky discuss next?

Examples:
- New Solana memecoin $BONK surging 300% 
- Ethereum gas fees hit all-time low
- Major whale moved 50,000 BTC to Coinbase
- BlackRock Bitcoin ETF rumors heating up
- Pump.fun launches new feature for creators
- DeFi protocol launches on Base chain
- Celebrity endorses new memecoin
- Regulatory news from SEC about crypto"></textarea>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <select id="topicType" style="width: 150px;">
                    <option value="general">General</option>
                    <option value="breaking_news">Breaking News</option>
                    <option value="market_analysis">Market Analysis</option>
                    <option value="memecoin">Memecoin Focus</option>
                    <option value="defi">DeFi Update</option>
                    <option value="regulatory">Regulatory News</option>
                    <option value="perky_report">üì∫ Perky Report</option>
                </select>
                
                <select id="topicPriority" style="width: 120px;">
                    <option value="normal">Normal</option>
                    <option value="urgent">Urgent</option>
                    <option value="low">Low Priority</option>
                </select>
                
                <input type="text" id="topicTags" placeholder="Tags (comma separated)" style="flex: 1;">
            </div>

            <div class="reporter-toggle">
                <span class="toggle-label">Reporter:</span>
                <div class="reporter-options">
                    <div class="reporter-option active" data-reporter="porky">üê∑ Porky</div>
                    <div class="reporter-option perky" data-reporter="perky">üì∫ Perky</div>
                </div>
            </div>

            <div class="topic-controls">
                <button class="btn" onclick="addTopic()">üìù Add to Queue</button>
                <button class="btn breaking" onclick="addUrgentTopic()">üö® Add Urgent</button>
                <button class="btn perky" onclick="addPerkyReport()">üì∫ Add Perky Report</button>
                <button class="btn stop" onclick="clearQueue()">üóëÔ∏è Clear Queue</button>
                <button class="btn" onclick="refreshQueue()">üîÑ Refresh</button>
            </div>

            <div class="topic-queue" id="topicQueue">
                <div style="color: #999; text-align: center; padding: 20px;">
                    No topics queued... Add some content for Porky!
                </div>
            </div>
        </div>

        <div class="knowledge-section">
            <h3>üß† Porky's Knowledge Base</h3>
            <p style="color: #fff; margin-bottom: 10px;">
                Porky's accumulated knowledge grows with every show. He references past topics to build ongoing narratives.
            </p>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <button class="btn knowledge" onclick="viewMemory()">üìö Recent Memory</button>
                <button class="btn knowledge" onclick="viewKnowledge()">üéì Knowledge Base</button>
                <button class="btn stop" onclick="clearMemory()">üßπ Clear All Data</button>
            </div>

            <div class="knowledge-list" id="knowledgeDisplay">
                <div style="color: #999; text-align: center; padding: 20px;">
                    Porky's knowledge base is empty... Start the show to build it!
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>üéµ Music Library Status</h3>
            <textarea id="songList" rows="3" placeholder="Music files will appear here automatically...">
Loading music library from GitHub...
            </textarea>
        </div>
    </div>

    <script>
        class OinkFMRadio {
            constructor() {
                this.isPlaying = false;
                this.currentSegment = null;
                this.songs = []; // Will auto-load from GitHub
                this.selectedReporter = 'porky';
                
                // DOM elements
                this.studioImg = document.getElementById('studioImg');
                this.porkyGif = document.getElementById('porkyGif');
                this.perkyReporter = document.getElementById('perkyReporter');
                this.audioPlayer = document.getElementById('audioPlayer');
                this.statusDisplay = document.getElementById('statusDisplay');
                this.newsTicker = document.getElementById('newsTicker');
                this.topicInput = document.getElementById('topicInput');
                this.topicQueue = document.getElementById('topicQueue');
                this.knowledgeDisplay = document.getElementById('knowledgeDisplay');
                
                this.setupEventListeners();
                this.updateStatus('üê∑ OINK FM loaded and ready!');
                this.loadMusicLibrary();
                this.refreshData();
            }

            async loadMusicLibrary() {
                console.log('üéµ Loading music library from GitHub...');
                this.updateStatus('üéµ Scanning GitHub for music files...');
                
                const musicUrls = [];
                
                // Generate URLs for songs (track001.mp3 to track100.mp3)
                for (let i = 1; i <= 100; i++) {
                    const trackNumber = i.toString().padStart(3, '0');
                    musicUrls.push(`https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/music/track${trackNumber}.mp3`);
                }
                
                // Test which songs exist
                const validSongs = [];
                let foundCount = 0;
                
                for (const url of musicUrls) {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        if (response.ok) {
                            validSongs.push(url);
                            foundCount++;
                            console.log(`‚úÖ Found song ${foundCount}: ${url.split('/').pop()}`);
                            
                            // Update status as we find songs
                            if (foundCount % 3 === 0) {
                                this.updateStatus(`üéµ Found ${foundCount} songs so far...`);
                            }
                        }
                    } catch (error) {
                        // Song doesn't exist, continue searching
                    }
                }
                
                this.songs = validSongs;
                
                if (validSongs.length > 0) {
                    this.updateStatus(`üéµ Music library loaded: ${validSongs.length} songs ready!`);
                    console.log(`üéµ Total music library: ${validSongs.length} songs`);
                    this.displayMusicLibrary();
                } else {
                    this.updateStatus('‚ùå No music found - upload MP3s to assets/music/');
                    console.log('‚ùå No songs found in GitHub music folder');
                    // Fallback to some working URLs
                    this.songs = [
                        'https://www.soundjay.com/misc/sounds/beep-07a.wav',
                        'https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3'
                    ];
                    this.updateStatus('üéµ Using fallback music - upload your tracks to assets/music/');
                }
                
                // Update song count
                document.getElementById('songCount').textContent = this.songs.length;
            }

            displayMusicLibrary() {
                const songListTextarea = document.getElementById('songList');
                if (songListTextarea && this.songs.length > 0) {
                    const songNames = this.songs.map(url => url.split('/').pop());
                    songListTextarea.value = songNames.join('\n');
                    songListTextarea.placeholder = `${this.songs.length} songs loaded automatically from GitHub`;
                    songListTextarea.rows = Math.min(10, Math.max(3, songNames.length));
                }
            }

            setupEventListeners() {
                // GIF event listeners - with safety checks
                if (this.porkyGif) {
                    this.porkyGif.addEventListener('load', () => {
                        console.log('‚úÖ Porky GIF loaded and ready');
                    });
                } else {
                    console.error('‚ùå Porky GIF element not found');
                }
                
                if (this.studioImg) {
                    this.studioImg.addEventListener('load', () => {
                        console.log('‚úÖ Studio image loaded');
                    });
                } else {
                    console.error('‚ùå Studio image element not found');
                }

                // Reporter toggle listeners
                document.querySelectorAll('.reporter-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        document.querySelectorAll('.reporter-option').forEach(opt => opt.classList.remove('active'));
                        e.target.classList.add('active');
                        this.selectedReporter = e.target.dataset.reporter;
                        console.log(`Selected reporter: ${this.selectedReporter}`);
                    });
                });

                // Auto-refresh data every 30 seconds
                setInterval(() => {
                    if (!this.isPlaying) {
                        this.refreshData();
                    }
                }, 30000);
            }

            async addTopic() {
                const content = this.topicInput.value.trim();
                if (!content) {
                    this.updateStatus('‚ùå Please enter a topic first!');
                    return;
                }

                const topic = {
                    content: content,
                    type: document.getElementById('topicType').value,
                    priority: document.getElementById('topicPriority').value,
                    tags: document.getElementById('topicTags').value.split(',').map(t => t.trim()).filter(t => t),
                    reporter: this.selectedReporter
                };

                try {
                    const response = await fetch('/api/enhanced-chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            action: 'add_topic',
                            topic: topic
                        })
                    });

                    if (response.ok) {
                        this.topicInput.value = '';
                        document.getElementById('topicTags').value = '';
                        this.updateStatus('‚úÖ Topic added to queue!');
                        await this.refreshQueue();
                    } else {
                        throw new Error('Failed to add topic');
                    }
                } catch (error) {
                    console.error('Add topic failed:', error);
                    this.updateStatus('‚ùå Failed to add topic');
                }
            }

            async addUrgentTopic() {
                document.getElementById('topicPriority').value = 'urgent';
                document.getElementById('topicType').value = 'breaking_news';
                await this.addTopic();
            }

            async addPerkyReport() {
                document.getElementById('topicType').value = 'perky_report';
                document.querySelector('[data-reporter="perky"]').click();
                await this.addTopic();
            }

            async removeTopic(topicId) {
                try {
                    const response = await fetch(`/api/enhanced-chat?type=topic&id=${topicId}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        this.updateStatus('‚úÖ Topic removed');
                        await this.refreshQueue();
                    }
                } catch (error) {
                    console.error('Remove topic failed:', error);
                    this.updateStatus('‚ùå Failed to remove topic');
                }
            }

            async clearQueue() {
                if (confirm('Clear all queued topics?')) {
                    try {
                        const response = await fetch('/api/enhanced-chat?type=queue', {
                            method: 'DELETE'
                        });

                        if (response.ok) {
                            this.updateStatus('‚úÖ Queue cleared');
                            await this.refreshQueue();
                        }
                    } catch (error) {
                        console.error('Clear queue failed:', error);
                    }
                }
            }

            async clearMemory() {
                if (confirm('Clear all memory and knowledge data? This cannot be undone!')) {
                    try {
                        const response = await fetch('/api/enhanced-chat?type=memory', {
                            method: 'DELETE'
                        });

                        if (response.ok) {
                            this.updateStatus('‚úÖ All data cleared');
                            await this.refreshData();
                        }
                    } catch (error) {
                        console.error('Clear memory failed:', error);
                    }
                }
            }

            async refreshData() {
                await Promise.all([
                    this.refreshQueue(),
                    this.refreshStats()
                ]);
            }

            async refreshQueue() {
                try {
                    const response = await fetch('/api/enhanced-chat?type=queue');
                    const data = await response.json();
                    this.displayQueue(data.queue || []);
                } catch (error) {
                    console.error('Refresh queue failed:', error);
                }
            }

            async refreshStats() {
                try {
                    const response = await fetch('/api/enhanced-chat');
                    const data = await response.json();
                    
                    document.getElementById('queueCount').textContent = data.queue?.length || 0;
                    document.getElementById('memoryCount').textContent = data.memory?.recent?.length || 0;
                    document.getElementById('knowledgeCount').textContent = data.knowledge?.length || 0;
                    document.getElementById('songCount').textContent = this.songs.length;
                } catch (error) {
                    console.error('Refresh stats failed:', error);
                }
            }

            displayQueue(queue) {
                if (queue.length === 0) {
                    this.topicQueue.innerHTML = `
                        <div style="color: #999; text-align: center; padding: 20px;">
                            No topics queued... Add some content for Porky!
                        </div>
                    `;
                } else {
                    this.topicQueue.innerHTML = queue.map(topic => `
                        <div class="topic-item ${topic.priority === 'urgent' ? 'urgent' : ''} ${topic.type === 'perky_report' || topic.reporter === 'perky' ? 'perky-report' : ''}">
                            <div class="topic-meta">
                                <span>${topic.type} ‚Ä¢ ${topic.priority} ‚Ä¢ ${topic.reporter === 'perky' ? 'üì∫ Perky' : 'üê∑ Porky'}</span>
                                <span>${new Date(topic.timestamp).toLocaleTimeString()}</span>
                                <button class="remove-btn" onclick="radio.removeTopic(${topic.id})">Remove</button>
                            </div>
                            <div class="topic-content">${topic.content}</div>
                            ${topic.tags && topic.tags.length > 0 ? `<div class="topic-tags">Tags: ${topic.tags.join(', ')}</div>` : ''}
                        </div>
                    `).join('');
                }
            }

            async viewMemory() {
                try {
                    const response = await fetch('/api/enhanced-chat?type=memory');
                    const data = await response.json();
                    this.displayKnowledge(data.memory?.recent || [], 'Recent Memory');
                } catch (error) {
                    console.error('View memory failed:', error);
                }
            }

            async viewKnowledge() {
                try {
                    const response = await fetch('/api/enhanced-chat?type=knowledge');
                    const data = await response.json();
                    this.displayKnowledge(data.knowledge || [], 'Knowledge Base');
                } catch (error) {
                    console.error('View knowledge failed:', error);
                }
            }

            displayKnowledge(items, title) {
                if (items.length === 0) {
                    this.knowledgeDisplay.innerHTML = `
                        <div style="color: #999; text-align: center; padding: 20px;">
                            No ${title.toLowerCase()} entries... Start the show to build knowledge!
                        </div>
                    `;
                } else {
                    this.knowledgeDisplay.innerHTML = `
                        <div style="color: #9c88ff; font-weight: bold; margin-bottom: 10px;">${title} (${items.length} entries)</div>
                        ${items.map(item => `
                            <div class="knowledge-item">
                                <div style="font-size: 11px; opacity: 0.7; margin-bottom: 3px;">
                                    ${new Date(item.timestamp).toLocaleString()}
                                </div>
                                <div>${item.topic || item.content?.substring(0, 100) + '...' || 'Unknown'}</div>
                                ${item.keywords ? `<div style="font-size: 11px; color: #6c63ff; margin-top: 3px;">Keywords: ${item.keywords.join(', ')}</div>` : ''}
                            </div>
                        `).join('')}
                    `;
                }
            }

            async fetchCryptoNews() {
                try {
                    this.updateStatus("üì° Fetching latest crypto data...");
                    
                    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage=24h');
                    const data = await response.json();
                    
                    return data.slice(0, 5);
                } catch (error) {
                    console.error('Error fetching crypto data:', error);
                    this.updateNewsTicker("‚ùå Failed to fetch crypto data");
                    return null;
                }
            }

            async generateRadioContent(cryptoData, topicData = null) {
                try {
                    const response = await fetch('/api/enhanced-chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            cryptoData,
                            requestType: 'segment',
                            topicData: topicData
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Update stats after each segment
                    await this.refreshStats();
                    
                    return data.content;
                    
                } catch (error) {
                    console.error('Enhanced content generation failed:', error);
                    this.updateStatus("‚ö†Ô∏è Enhanced API Error - using fallback");
                    return "OINK OINK! Porky here on OINK FM! My topic queue is loaded with hot intel and my knowledge base is growing every day! The crypto markets are hog wild and we're building something special here! Let me spin some tracks while I process all this beautiful data!";
                }
            }

            async generatePerkyReport(content) {
                try {
                    const response = await fetch('/api/enhanced-chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            cryptoData: await this.fetchCryptoNews(),
                            requestType: 'perky_report',
                            fieldIntel: content
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    await this.refreshStats();
                    return data.content;
                    
                } catch (error) {
                    console.error('Perky report generation failed:', error);
                    return `Good evening, I'm Perky with a special report. ${content} We'll have more updates on this developing story as it unfolds. Back to you, Porky.`;
                }
            }

            async perkyReport() {
                const content = this.topicInput.value.trim();
                if (!content) {
                    this.updateStatus('‚ùå Enter story content for Perky first!');
                    return;
                }

                try {
                    this.updateStatus('üì∫ Perky is preparing her report...');
                    
                    // Generate both Perky's report AND Porky's follow-up in parallel
                    const [perkyScript, porkyFollowUp] = await Promise.all([
                        this.generatePerkyReport(content),
                        this.generatePorkyFollowUp(content, null) // Generate Porky's response based on topic
                    ]);
                    
                    // Clear the input
                    this.topicInput.value = '';
                    
                    // Start TTS generation for Perky while showing animation
                    this.updateStatus('üì∫ Perky: Live from the newsroom!');
                    const perkyAudioPromise = this.generateTTSAudio(perkyScript, 'perky');
                    
                    // Show Perky reporting (animation plays while TTS generates)
                    await this.showPerkyReporting();
                    
                    // Wait for TTS to be ready and play immediately
                    const perkyAudio = await perkyAudioPromise;
                    await this.playAudio(perkyAudio);
                    
                    // Start generating Porky's TTS while Perky is talking
                    const porkyAudioPromise = this.generateTTSAudio(porkyFollowUp, 'porky');
                    
                    // Hide Perky
                    await this.hidePerky();
                    
                    // Show Porky talking
                    this.showPorkyTalking();
                    this.updateStatus('üéôÔ∏è Porky: Thanks for that update, Perky!');
                    
                    // Porky's audio should be ready now - play immediately
                    const porkyAudio = await porkyAudioPromise;
                    await this.playAudio(porkyAudio);
                    
                    // Return to studio and go straight to music
                    this.showStudio();
                    this.updateStatus('üéµ Now spinning tracks after the report...');
                    
                    // Play music (don't generate another segment)
                    await this.playRandomSong();
                    
                } catch (error) {
                    console.error('Perky report failed:', error);
                    this.updateStatus('‚ùå Perky report system malfunction!');
                    await this.hidePerky();
                }
            }

            async generatePorkyFollowUp(originalContent, perkyReport) {
                try {
                    const response = await fetch('/api/enhanced-chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            cryptoData: await this.fetchCryptoNews(),
                            requestType: 'porky_followup',
                            originalContent: originalContent,
                            perkyReport: perkyReport
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.content;
                    
                } catch (error) {
                    console.error('Porky follow-up generation failed:', error);
                    return `OINK OINK! Thanks for that excellent report, Perky! That's exactly the kind of intel our listeners need to hear! My knowledge base is updating with this information and we'll keep tracking this story. Now let me spin some tracks while I process all this data!`;
                }
            }

            async breakingNews() {
                const content = this.topicInput.value.trim();
                if (!content) {
                    this.updateStatus('‚ùå Enter breaking news content first!');
                    return;
                }

                try {
                    this.updateStatus('üö® BREAKING: Porky received urgent intel!');
                    
                    const radioScript = await this.generateBreakingNewsContent(content);
                    
                    // Clear the input
                    this.topicInput.value = '';
                    
                    // Show Porky talking
                    this.showPorkyTalking();
                    this.updateStatus('üéôÔ∏è Porky: BREAKING NEWS ALERT!');
                    
                    // Speak the content
                    await this.textToSpeech(radioScript, 'porky');
                    
                    // Return to studio
                    this.showStudio();
                    this.updateStatus('üìª Breaking news delivered!');
                    
                } catch (error) {
                    console.error('Breaking news failed:', error);
                    this.updateStatus('‚ùå Breaking news system malfunction!');
                }
            }

            async generateBreakingNewsContent(intel) {
                try {
                    const response = await fetch('/api/enhanced-chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            cryptoData: await this.fetchCryptoNews(),
                            requestType: 'breaking_news',
                            fieldIntel: intel
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    await this.refreshStats();
                    return data.content;
                    
                } catch (error) {
                    console.error('Breaking news generation failed:', error);
                    return `OINK OINK! This is Porky with URGENT intel! ${intel} This is absolutely mental! My knowledge base is telling me this could be huge! More details coming as this develops!`;
                }
            }

            async textToSpeech(text, voiceType = 'porky') {
                try {
                    // Use different voice IDs for Porky and Perky
                    const voiceId = voiceType === 'perky' ? '19STyYD15bswVz51nqLf' : 'porky';
                    
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            text: text,
                            voice: voiceId
                        })
                    });

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        
                        return new Promise((resolve) => {
                            const audio = new Audio(audioUrl);
                            audio.onended = () => {
                                URL.revokeObjectURL(audioUrl);
                                resolve();
                            };
                            audio.onerror = () => {
                                console.error('ElevenLabs audio playback failed');
                                resolve();
                            };
                            audio.play();
                        });
                    } else {
                        throw new Error('ElevenLabs TTS failed');
                    }
                } catch (error) {
                    console.error('ElevenLabs TTS error, falling back to browser TTS:', error);
                    
                    // Fallback to browser TTS
                    return new Promise((resolve) => {
                        if ('speechSynthesis' in window) {
                            const utterance = new SpeechSynthesisUtterance(text);
                            utterance.rate = voiceType === 'perky' ? 1.0 : 0.9;
                            utterance.pitch = voiceType === 'perky' ? 1.3 : 1.1;
                            utterance.volume = 0.8;
                            
                            const voices = speechSynthesis.getVoices();
                            let preferredVoice;
                            
                            if (voiceType === 'perky') {
                                // Try to find a female voice for Perky
                                preferredVoice = voices.find(voice => 
                                    voice.name.toLowerCase().includes('female') || 
                                    voice.name.toLowerCase().includes('woman') ||
                                    voice.name.includes('Zira') ||
                                    voice.name.includes('Hazel')
                                );
                            }
                            
                            if (!preferredVoice) {
                                preferredVoice = voices.find(voice => 
                                    voice.name.includes('Google') || 
                                    voice.name.includes('Microsoft') ||
                                    voice.lang.includes('en-US')
                                );
                            }
                            
                            if (preferredVoice) {
                                utterance.voice = preferredVoice;
                            }
                            
                            utterance.onend = resolve;
                            utterance.onerror = resolve;
                            
                            speechSynthesis.speak(utterance);
                        } else {
                            setTimeout(resolve, text.length * 50);
                        }
                    });
                }
            }

            async generateTTSAudio(text, voiceType = 'porky') {
                try {
                    const voiceId = voiceType === 'perky' ? '19STyYD15bswVz51nqLf' : 'porky';
                    
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            text: text,
                            voice: voiceId
                        })
                    });

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        return URL.createObjectURL(audioBlob);
                    } else {
                        throw new Error('ElevenLabs TTS failed');
                    }
                } catch (error) {
                    console.error('TTS audio generation failed:', error);
                    return null; // Will fall back to browser TTS
                }
            }

            async playAudio(audioUrl) {
                if (audioUrl) {
                    // Play ElevenLabs audio
                    return new Promise((resolve) => {
                        const audio = new Audio(audioUrl);
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            resolve();
                        };
                        audio.onerror = () => {
                            console.error('Audio playback failed, falling back to browser TTS');
                            URL.revokeObjectURL(audioUrl);
                            resolve();
                        };
                        audio.play().catch(() => {
                            console.error('Audio play failed');
                            resolve();
                        });
                    });
                } else {
                    // Fallback - this shouldn't happen with pre-generated audio
                    console.log('No audio URL provided, skipping playback');
                    return Promise.resolve();
                }
            }
                try {
                    // Use different voice IDs for Porky and Perky
                    const voiceId = voiceType === 'perky' ? '19STyYD15bswVz51nqLf' : 'porky';
                    
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            text: text,
                            voice: voiceId
                        })
                    });

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        
                        return new Promise((resolve) => {
                            const audio = new Audio(audioUrl);
                            audio.onended = () => {
                                URL.revokeObjectURL(audioUrl);
                                resolve();
                            };
                            audio.onerror = () => {
                                console.error('ElevenLabs audio playback failed');
                                resolve();
                            };
                            audio.play();
                        });
                    } else {
                        throw new Error('ElevenLabs TTS failed');
                    }
                } catch (error) {
                    console.error('ElevenLabs TTS error, falling back to browser TTS:', error);
                    
                    // Fallback to browser TTS
                    return new Promise((resolve) => {
                        if ('speechSynthesis' in window) {
                            const utterance = new SpeechSynthesisUtterance(text);
                            utterance.rate = voiceType === 'perky' ? 1.0 : 0.9;
                            utterance.pitch = voiceType === 'perky' ? 1.3 : 1.1;
                            utterance.volume = 0.8;
                            
                            const voices = speechSynthesis.getVoices();
                            let preferredVoice;
                            
                            if (voiceType === 'perky') {
                                // Try to find a female voice for Perky
                                preferredVoice = voices.find(voice => 
                                    voice.name.toLowerCase().includes('female') || 
                                    voice.name.toLowerCase().includes('woman') ||
                                    voice.name.includes('Zira') ||
                                    voice.name.includes('Hazel')
                                );
                            }
                            
                            if (!preferredVoice) {
                                preferredVoice = voices.find(voice => 
                                    voice.name.includes('Google') || 
                                    voice.name.includes('Microsoft') ||
                                    voice.lang.includes('en-US')
                                );
                            }
                            
                            if (preferredVoice) {
                                utterance.voice = preferredVoice;
                            }
                            
                            utterance.onend = resolve;
                            utterance.onerror = resolve;
                            
                            speechSynthesis.speak(utterance);
                        } else {
                            setTimeout(resolve, text.length * 50);
                        }
                    });
                }
            }

            async showPerkyReporting() {
                return new Promise((resolve) => {
                    // Show studio background
                    this.showStudio();
                    
                    // Slide Perky into frame
                    this.perkyReporter.classList.add('visible');
                    
                    console.log('üì∫ Perky sliding into frame...');
                    
                    // Wait for animation to complete
                    setTimeout(resolve, 800);
                });
            }

            async hidePerky() {
                return new Promise((resolve) => {
                    this.perkyReporter.classList.remove('visible');
                    
                    console.log('üì∫ Perky sliding out of frame...');
                    
                    // Wait for animation to complete
                    setTimeout(resolve, 800);
                });
            }

            async startShow() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.justCompletedReport = false;
                this.updateStatus("üéôÔ∏è OINK FM is going LIVE!");
                
                // Check for queued topics that need specific handling
                let queuedTopics = [];
                try {
                    const response = await fetch('/api/enhanced-chat?type=queue');
                    const data = await response.json();
                    queuedTopics = data.queue || [];
                } catch (error) {
                    console.error('Failed to fetch queue:', error);
                }
                
                // Pre-generate first segment
                let nextRadioScript = null;
                let nextCryptoData = null;
                
                while (this.isPlaying) {
                    try {
                        // Check if we just completed a report and should go straight to music
                        if (this.justCompletedReport) {
                            this.justCompletedReport = false;
                            this.updateStatus("üéµ Post-report music time...");
                            await this.playRandomSong();
                            
                            // After music, continue with normal flow
                            if (this.isPlaying) {
                                await this.delay(2000);
                            }
                            continue;
                        }
                        
                        // Check for priority Perky reports or urgent topics
                        const urgentPerkyReport = queuedTopics.find(topic => 
                            topic.type === 'perky_report' || 
                            (topic.reporter === 'perky' && topic.priority === 'urgent')
                        );
                        
                        if (urgentPerkyReport) {
                            // Handle Perky report
                            await this.handlePerkyReport(urgentPerkyReport);
                            
                            // Remove the handled topic from queue
                            await this.removeTopic(urgentPerkyReport.id);
                            
                            // Refresh queue for next iteration
                            const refreshResponse = await fetch('/api/enhanced-chat?type=queue');
                            const refreshData = await refreshResponse.json();
                            queuedTopics = refreshData.queue || [];
                            
                            continue; // This will check justCompletedReport flag
                        }
                        
                        // Regular segment handling with pre-generated TTS
                        if (!nextRadioScript) {
                            nextCryptoData = await this.fetchCryptoNews();
                            if (nextCryptoData) {
                                this.updateNewsTicker(nextCryptoData);
                                this.updateStatus("ü§ñ Porky is preparing his thoughts...");
                                
                                // Check for regular queued topics
                                const nextTopic = queuedTopics.find(topic => topic.type !== 'perky_report' && topic.reporter !== 'perky');
                                nextRadioScript = await this.generateRadioContent(nextCryptoData, nextTopic);
                                
                                if (nextTopic) {
                                    await this.removeTopic(nextTopic.id);
                                    const refreshResponse = await fetch('/api/enhanced-chat?type=queue');
                                    const refreshData = await refreshResponse.json();
                                    queuedTopics = refreshData.queue || [];
                                }
                            }
                        }
                        
                        // Generate TTS while showing Porky animation
                        if (nextRadioScript) {
                            this.showPorkyTalking();
                            this.updateStatus("üéôÔ∏è Porky is dropping knowledge...");
                            
                            // Generate and play TTS
                            const audioUrl = await this.generateTTSAudio(nextRadioScript, 'porky');
                            await this.playAudio(audioUrl);
                            
                            // Clear used content
                            nextRadioScript = null;
                            nextCryptoData = null;
                        }
                        
                        // Switch to studio view for music
                        this.showStudio();
                        this.updateStatus("üéµ Now spinning tracks...");
                        
                        // Start background content generation WHILE music plays
                        const backgroundGeneration = this.generateNextSegment(queuedTopics);
                        
                        // Play music
                        await this.playRandomSong();
                        
                        // Get the pre-generated content (should be ready by now)
                        try {
                            const result = await backgroundGeneration;
                            nextRadioScript = result.content;
                            nextCryptoData = result.cryptoData;
                            console.log("‚úÖ Next segment ready! No delay for next speech.");
                        } catch (error) {
                            console.error("Background generation failed:", error);
                        }
                        
                        // Small pause between segments
                        if (this.isPlaying) {
                            await this.delay(2000);
                        }
                        
                    } catch (error) {
                        console.error('Error in show loop:', error);
                        this.updateStatus("‚ùå Something went wrong, retrying...");
                        await this.delay(30000);
                    }
                }
            }

            async handlePerkyReport(topic) {
                try {
                    this.updateStatus('üì∫ Perky is preparing her report...');
                    
                    // Generate both scripts in parallel for speed
                    const [perkyScript, porkyFollowUp] = await Promise.all([
                        this.generatePerkyReport(topic.content),
                        this.generatePorkyFollowUp(topic.content, null)
                    ]);
                    
                    // Start TTS generation for Perky while showing animation
                    this.updateStatus('üì∫ Perky: Live from the newsroom!');
                    const perkyAudioPromise = this.generateTTSAudio(perkyScript, 'perky');
                    
                    // Show Perky reporting
                    await this.showPerkyReporting();
                    
                    // Play Perky's audio (should be ready by now)
                    const perkyAudio = await perkyAudioPromise;
                    await this.playAudio(perkyAudio);
                    
                    // Generate Porky's TTS while transitioning
                    const porkyAudioPromise = this.generateTTSAudio(porkyFollowUp, 'porky');
                    
                    // Hide Perky and show Porky
                    await this.hidePerky();
                    this.showPorkyTalking();
                    this.updateStatus('üéôÔ∏è Porky: Thanks for that update, Perky!');
                    
                    // Play Porky's response (should be ready)
                    const porkyAudio = await porkyAudioPromise;
                    await this.playAudio(porkyAudio);
                    
                    // Return to studio - this will lead to music in the main loop
                    this.showStudio();
                    this.updateStatus('üìª Report complete - back to music...');
                    
                    // Mark this as completed so main loop continues with music
                    this.justCompletedReport = true;
                    
                } catch (error) {
                    console.error('Perky report handling failed:', error);
                    this.updateStatus('‚ùå Perky report system malfunction!');
                    await this.hidePerky();
                }
            }

            // Add this new function for background generation
            async generateNextSegment(queuedTopics = []) {
                try {
                    console.log("üîÑ Generating next segment in background...");
                    
                    const cryptoData = await this.fetchCryptoNews();
                    if (!cryptoData) {
                        throw new Error("Failed to fetch crypto data");
                    }
                    
                    // Check for next topic to cover
                    const nextTopic = queuedTopics.find(topic => topic.type !== 'perky_report' && topic.reporter !== 'perky');
                    const content = await this.generateRadioContent(cryptoData, nextTopic);
                    
                    console.log("‚úÖ Background generation complete!");
                    return { content, cryptoData };
                    
                } catch (error) {
                    console.error("Background generation error:", error);
                    throw error;
                }
            }

            async playRandomSong() {
                if (this.songs.length === 0) {
                    console.log('üéµ No songs available, skipping music segment');
                    await this.delay(30000);
                    return;
                }
                
                // Try up to 3 different songs if one fails
                for (let attempt = 0; attempt < 3; attempt++) {
                    const randomSong = this.songs[Math.floor(Math.random() * this.songs.length)];
                    
                    try {
                        console.log(`üéµ Attempting to play: ${randomSong.split('/').pop()} (attempt ${attempt + 1})`);
                        
                        return new Promise((resolve) => {
                            this.audioPlayer.onerror = (error) => {
                                console.error(`‚ùå Song failed to play:`, error);
                                console.error(`‚ùå Failed URL: ${randomSong}`);
                                resolve();
                            };
                            
                            this.audioPlayer.oncanplaythrough = () => {
                                console.log(`‚úÖ Song loaded successfully: ${randomSong.split('/').pop()}`);
                                this.audioPlayer.play().catch(e => {
                                    console.error('Play error:', e);
                                    resolve();
                                });
                            };
                            
                            this.audioPlayer.onended = () => {
                                console.log(`üéµ Song finished playing`);
                                resolve();
                            };
                            
                            // Set source and start loading
                            this.audioPlayer.src = randomSong;
                            
                            // Timeout after 4 minutes
                            const timeout = setTimeout(() => {
                                console.log(`‚è∞ Song timeout reached`);
                                resolve();
                            }, 240000);
                            
                            this.audioPlayer.onended = () => {
                                clearTimeout(timeout);
                                resolve();
                            };
                        });
                        
                    } catch (error) {
                        console.error(`‚ùå Song attempt ${attempt + 1} failed:`, error);
                        if (attempt === 2) {
                            console.log('üéµ All song attempts failed, continuing without music');
                            await this.delay(30000);
                            return;
                        }
                    }
                }
            }

            stop() {
                this.isPlaying = false;
                this.audioPlayer.pause();
                this.showStudio();
                this.hidePerky();
                this.updateStatus("üìª OINK FM is off the air");
                speechSynthesis.cancel();
            }

            skipToNext() {
                if (this.isPlaying) {
                    this.audioPlayer.pause();
                    speechSynthesis.cancel();
                    this.updateStatus("‚è≠Ô∏è Skipping to next segment...");
                }
            }

            showPorkyTalking() {
                if (this.studioImg) {
                    this.studioImg.classList.remove('visible');
                }
                if (this.porkyGif) {
                    this.porkyGif.classList.add('visible');
                }
                if (this.perkyReporter) {
                    this.perkyReporter.classList.remove('visible');
                }
                console.log('üê∑ Showing Porky GIF - should be animating!');
            }

            showStudio() {
                if (this.porkyGif) {
                    this.porkyGif.classList.remove('visible');
                }
                if (this.studioImg) {
                    this.studioImg.classList.add('visible');
                }
                console.log('üéµ Showing studio image');
            }

            updateStatus(message) {
                this.statusDisplay.textContent = message;
                console.log(message);
            }

            updateNewsTicker(data) {
                if (Array.isArray(data)) {
                    const tickerText = data.map(coin => 
                        `${coin.name}: ${coin.current_price.toFixed(2)} (${coin.price_change_percentage_24h > 0 ? '+' : ''}${coin.price_change_percentage_24h.toFixed(1)}%)`
                    ).join(' ‚Ä¢ ');
                    this.newsTicker.textContent = tickerText;
                } else {
                    this.newsTicker.textContent = data;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the radio
        const radio = new OinkFMRadio();

        // Global functions for buttons
        function startShow() {
            radio.startShow();
        }

        function stopShow() {
            radio.stop();
        }

        function skipToNext() {
            radio.skipToNext();
        }

        function addTopic() {
            radio.addTopic();
        }

        function addUrgentTopic() {
            radio.addUrgentTopic();
        }

        function addPerkyReport() {
            radio.addPerkyReport();
        }

        function addPerkyReport() {
            radio.addPerkyReport();
        }

        function clearQueue() {
            radio.clearQueue();
        }

        function clearMemory() {
            radio.clearMemory();
        }

        function refreshQueue() {
            radio.refreshQueue();
        }

        function viewMemory() {
            radio.viewMemory();
        }

        function viewKnowledge() {
            radio.viewKnowledge();
        }

        function breakingNews() {
            radio.breakingNews();
        }

        function perkyReport() {
            radio.perkyReport();
        }

        // Load voices when available
        if ('speechSynthesis' in window) {
            speechSynthesis.onvoiceschanged = () => {
                console.log('Available voices:', speechSynthesis.getVoices().map(v => v.name));
            };
        }
    </script>
</body>
</html>
